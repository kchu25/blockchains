<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700;900&display=swap" rel="stylesheet">
  <style>
    @font-face {
      font-family: 'BPdots';
      src: url('/blockchains/assets/fonts/BPdots/BPdots.otf') format('opentype');
      font-weight: normal;
      font-style: normal;
    }
    @font-face {
      font-family: 'BPdots';
      src: url('/blockchains/assets/fonts/BPdots/BPdotsBold.otf') format('opentype');
      font-weight: bold;
      font-style: normal;
    }
  </style>
   <link rel="stylesheet" href="/libs/katex/katex.min.css">
     
   <link rel="stylesheet" href="/libs/highlight/styles/atom-one-dark.min.css">
   
  <link rel="stylesheet" href="/css/franklin.css">
<link rel="stylesheet" href="/css/hypertext.css">
<link rel="icon" href="/assets/favicon.png">

   <title>CAP Theorem: Why 'Old' Blockchains Win in Sovereign Finance</title>  
</head>
<body>
<header>
  <h1 style="color:#283747; font-family:'BPdots', monospace; font-size:2.5em; font-weight:normal; letter-spacing:0.1em">blockchains</h1>
  <nav>
    <a href="/" class="current">Tags</a>
  | <a href="/blog/" >Notes</a>
  <hr/>
  </nav>
</header>


<!-- Content appended here -->
<div class="franklin-content"><h1 id="cap_theorem_why_old_blockchains_win_in_sovereign_finance"><a href="#cap_theorem_why_old_blockchains_win_in_sovereign_finance" class="header-anchor">CAP Theorem: Why &quot;Old&quot; Blockchains Win in Sovereign Finance</a></h1>
<p><strong>TL;DR:</strong> The CAP theorem proves you can&#39;t have perfect consistency, availability, and partition tolerance simultaneously. Every blockchain makes a tradeoff. When a nation-state is choosing infrastructure to store its wealth, the way it ranks these tradeoffs is radically different from a retail trader chasing &quot;fast and cheap.&quot; Understanding CAP explains why Ethereum—slow, expensive, &quot;boring&quot;—has quietly secured an unassailable moat in institutional finance.</p>
<hr />
<h2 id="the_cap_theorem"><a href="#the_cap_theorem" class="header-anchor">The CAP Theorem</a></h2>
<p>In 2000, Eric Brewer conjectured &#40;and in 2002, Gilbert &amp; Lynch proved&#41; a fundamental constraint on distributed systems:</p>
<blockquote>
<p><strong>Any distributed data store can provide at most two of the following three guarantees simultaneously:</strong></p>
</blockquote>
\[\text{Pick 2 of 3:} \quad \underbrace{C}_{\text{Consistency}} \quad \underbrace{A}_{\text{Availability}} \quad \underbrace{P}_{\text{Partition Tolerance}}\]
<p>Let&#39;s define each precisely.</p>
<h3 id="consistency_c"><a href="#consistency_c" class="header-anchor">Consistency &#40;C&#41;</a></h3>
<p>Every read receives the most recent write or an error. All nodes see the same data at the same time.</p>
\[\forall \text{ nodes } i, j: \quad \text{read}(i) = \text{read}(j) \quad \text{after any write}\]
<p><strong>In blockchain terms:</strong> If Alice sends 10 ETH to Bob, every node in the network agrees on this fact—no node thinks Alice still has those 10 ETH. There&#39;s one truth, everywhere, always.</p>
<p><strong>Real-world analogy:</strong> A bank ledger where every branch sees the exact same account balance at the exact same moment. No discrepancies, ever.</p>
<h3 id="availability_a"><a href="#availability_a" class="header-anchor">Availability &#40;A&#41;</a></h3>
<p>Every request to a non-failing node receives a response—no timeouts, no &quot;system is down&quot; messages.</p>
\[\forall \text{ non-failing node } i: \quad \text{request}(i) \to \text{response}(i) \quad \text{(finite time)}\]
<p><strong>In blockchain terms:</strong> You can always submit a transaction and get a result. The network never says &quot;come back later.&quot; Even during high load, your transaction gets processed.</p>
<p><strong>Real-world analogy:</strong> An ATM that always dispenses cash or tells you your balance, 24/7/365. Never an &quot;out of service&quot; screen.</p>
<h3 id="partition_tolerance_p"><a href="#partition_tolerance_p" class="header-anchor">Partition Tolerance &#40;P&#41;</a></h3>
<p>The system continues operating even when network messages between nodes are lost or delayed—i.e., the network graph splits into disconnected components.</p>
\[\text{System operates correctly even when} \quad G = G_1 \cup G_2, \quad G_1 \cap G_2 = \emptyset\]
<p>where \(G\) is the network graph and \(G_1, G_2\) are disconnected subgraphs.</p>
<p><strong>In blockchain terms:</strong> Even if the internet backbone between the US and Europe goes down, nodes on both sides keep working. The system doesn&#39;t collapse because some nodes can&#39;t talk to others.</p>
<p><strong>Real-world analogy:</strong> Your local branch bank keeps working even if the phone line to headquarters is cut. It might not have the latest data, but it doesn&#39;t shut down.</p>
<hr />
<h2 id="why_you_cant_have_all_three"><a href="#why_you_cant_have_all_three" class="header-anchor">Why You Can&#39;t Have All Three</a></h2>
<p>Here&#39;s the intuitive proof. Suppose a network partition occurs—nodes A and B can&#39;t communicate:</p>
<pre><code class="language-julia">Node A                    Node B
   ┌──────┐    ╳ BROKEN ╳   ┌──────┐
   │Data: x│ ←───────────→  │Data: x│
   └──────┘                  └──────┘
   
   Client writes x → y to Node A.
   
   Node A                    Node B
   ┌──────┐    ╳ BROKEN ╳   ┌──────┐
   │Data: y│ ←───────────→  │Data: x│  ← stale&#33;
   └──────┘                  └──────┘</code></pre>
<p>Now a client reads from Node B. You have two choices:</p>
<ol>
<li><p><strong>Return the stale value</strong> \(x\) → You maintained <strong>Availability</strong> &#40;B responded&#41; but broke <strong>Consistency</strong> &#40;B returned old data&#41;</p>
</li>
<li><p><strong>Return an error / wait</strong> → You maintained <strong>Consistency</strong> &#40;no wrong answers&#41; but broke <strong>Availability</strong> &#40;B didn&#39;t respond&#41;</p>
</li>
</ol>
<p>Since real networks <em>will</em> partition &#40;undersea cables get cut, data centers lose power, governments firewall regions&#41;, you&#39;re effectively always choosing between <strong>C</strong> and <strong>A</strong>.</p>
\[\boxed{P \text{ is mandatory} \implies \text{Choose: } C \text{ or } A}\]
<hr />
<h2 id="cap_in_blockchain_land"><a href="#cap_in_blockchain_land" class="header-anchor">CAP in Blockchain Land</a></h2>
<p>Every blockchain makes this tradeoff, whether its marketing admits it or not.</p>
<h3 id="cp_systems_consistency_partition_tolerance"><a href="#cp_systems_consistency_partition_tolerance" class="header-anchor">CP Systems: Consistency &#43; Partition Tolerance</a></h3>
<p><strong>Sacrifice:</strong> Availability. The system may halt or slow down to ensure correctness.</p>
<p><strong>Examples:</strong> Bitcoin, Ethereum</p>
<ul>
<li><p>Bitcoin: If the network partitions, the shorter chain gets reorganized &#40;reorged&#41;. Transactions on the &quot;wrong&quot; chain are rolled back. During this time, you can&#39;t be sure your transaction is final—so effectively, availability is sacrificed for consistency.</p>
</li>
<li><p>Ethereum: Finalizes blocks every ~13 minutes via Casper FFG. Until finalization, there&#39;s a &#40;small&#41; chance of reorganization. The system prioritizes &quot;one correct history&quot; over &quot;instant responses.&quot;</p>
</li>
</ul>
<p><strong>The tradeoff in practice:</strong></p>
\[\text{Bitcoin: } \underbrace{6 \text{ confirmations}}_{\approx 60 \text{ min}} \text{ for high-value settlement}\]
\[\text{Ethereum: } \underbrace{2 \text{ epochs}}_{\approx 13 \text{ min}} \text{ for finality}\]
<p>You wait. But when you&#39;re done waiting, the answer is <em>correct</em>.</p>
<h3 id="ap_systems_availability_partition_tolerance"><a href="#ap_systems_availability_partition_tolerance" class="header-anchor">AP Systems: Availability &#43; Partition Tolerance</a></h3>
<p><strong>Sacrifice:</strong> Consistency. The system always responds, but different nodes might give different answers.</p>
<p><strong>Examples:</strong> Solana, many high-throughput chains</p>
<ul>
<li><p>Solana: Prioritizes speed and availability—400ms block times, always responsive. But it&#39;s had multiple network outages and requires validators to have very high hardware specs, reducing true partition tolerance. When things go wrong, the chain halts entirely &#40;which is actually a CP behavior forced by failure, not design&#41;.</p>
</li>
<li><p>Many &quot;fast&quot; chains: Offer optimistic responses before true consensus, meaning your transaction might appear confirmed, then get reversed.</p>
</li>
</ul>
<p><strong>The tradeoff in practice:</strong></p>
\[\text{Solana: } \underbrace{400\text{ms blocks}}_{\text{incredibly fast}} \text{ but } \underbrace{7+ \text{ major outages}}_{\text{since 2022}}\]
<p>You get speed. But &quot;confirmed&quot; doesn&#39;t always mean &quot;final.&quot;</p>
<h3 id="the_spectrum"><a href="#the_spectrum" class="header-anchor">The Spectrum</a></h3>
<p>In practice, it&#39;s not binary—it&#39;s a spectrum:</p>
<pre><code class="language-julia">Strong Consistency ←─────────────────────→ High Availability
&#40;slow, safe&#41;                               &#40;fast, risky&#41;

  Bitcoin    Ethereum    Cosmos    Avalanche    Solana
    │           │          │          │           │
    ▼           ▼          ▼          ▼           ▼
  ~60 min    ~13 min    ~6 sec     ~2 sec     ~400 ms
  
  &quot;Your money is definitely there&quot;  ···→  &quot;Probably there, very fast&quot;</code></pre>
<hr />
<h2 id="the_sovereign-grade_perspective"><a href="#the_sovereign-grade_perspective" class="header-anchor">The Sovereign-Grade Perspective</a></h2>
<p>Now here&#39;s where it gets interesting. In the research world and institutional finance of 2026, the ranking of importance is very different from the &quot;hype&quot; rankings you see on social media. While a retail investor might prioritize &quot;Price Gains&quot; or &quot;Speed,&quot; a country or a central bank prioritizes the <strong>ability to sleep at night.</strong></p>
<p>When a nation-state evaluates a technology to store its &quot;energy&quot; &#40;wealth&#41;, it&#39;s really asking: <strong>which side of the CAP tradeoff do I want to be on?</strong></p>
<p>The answer, every time, is <strong>CP</strong>—Consistency and Partition Tolerance.</p>
<h3 id="why_countries_choose_cp"><a href="#why_countries_choose_cp" class="header-anchor">Why Countries Choose CP</a></h3>
<p>A nation&#39;s reserve is not a Uniswap trade. Consider what&#39;s at stake:</p>
<table><tr><th align="right">Scenario</th><th align="right">AP System &#40;fast, maybe wrong&#41;</th><th align="right">CP System &#40;slow, definitely right&#41;</th></tr><tr><td align="right">&#36;10B treasury transfer</td><td align="right">Confirmed in 400ms... maybe reversed tomorrow</td><td align="right">Confirmed in 13 min. <strong>Final. Period.</strong></td></tr><tr><td align="right">Network partition during crisis</td><td align="right">Conflicting states on each side</td><td align="right">System waits for consensus, no conflicting states</td></tr><tr><td align="right">Auditing 5 years later</td><td align="right">&quot;Which version of history is canonical?&quot;</td><td align="right">One history. Immutable. Provable.</td></tr></table>
<p>For a country, a <strong>false confirmation</strong> on a &#36;10B transfer is an existential crisis. Waiting 13 minutes is a rounding error compared to the 3–5 days SWIFT currently takes.</p>
<h3 id="the_sovereign-grade_ranking"><a href="#the_sovereign-grade_ranking" class="header-anchor">The Sovereign-Grade Ranking</a></h3>
<p>Here is how these properties are ranked when a nation-state evaluates blockchain technology:</p>
<table><tr><th align="right">Rank</th><th align="right">Property</th><th align="right">Importance</th><th align="right">Why</th></tr><tr><td align="right"><strong>1</strong></td><td align="right"><strong>Security &amp; Immutability</strong></td><td align="right"><strong>Critical</strong></td><td align="right">If the ledger can be rolled back or hacked, the country loses its entire treasury and public trust. Non-negotiable. This is the <strong>C</strong> in CAP—one canonical truth.</td></tr><tr><td align="right"><strong>2</strong></td><td align="right"><strong>Regulatory Compliance</strong></td><td align="right"><strong>High</strong></td><td align="right">Systems must support AML/KYC hooks. &quot;Privacy-only&quot; coins are usually rejected. Consistency matters here too—regulators need one auditable history.</td></tr><tr><td align="right"><strong>3</strong></td><td align="right"><strong>Interoperability</strong></td><td align="right"><strong>High</strong></td><td align="right">A country doesn&#39;t want to be an island. The tech must talk to the world&#39;s banks and trade networks. Requires standardized, consistent state across bridges.</td></tr><tr><td align="right"><strong>4</strong></td><td align="right"><strong>Decentralization</strong></td><td align="right"><strong>Moderate</strong></td><td align="right">Countries prefer <em>partial</em> decentralization—decentralized enough to be unstoppable, centralized enough to have some control. This is about <strong>P</strong>—surviving partitions and attacks.</td></tr><tr><td align="right"><strong>5</strong></td><td align="right"><strong>Scalability &#40;Throughput&#41;</strong></td><td align="right"><strong>Moderate</strong></td><td align="right">Important but secondary. Solved by building Layer 2s &#40;fast lanes&#41; on top of a secure Layer 1 &#40;the vault&#41;.</td></tr><tr><td align="right"><strong>6</strong></td><td align="right"><strong>Latency &#40;Speed&#41;</strong></td><td align="right"><strong>Low</strong></td><td align="right">For national settlement, 10 minutes &#40;Bitcoin&#41; or 12 seconds &#40;Ethereum&#41; is <em>much faster</em> than 3–5 day SWIFT transfers. They don&#39;t need 400ms.</td></tr></table>
<p>Notice: the top priorities—security, immutability, one canonical history, auditability—are all <strong>Consistency</strong> properties. Speed is last. Countries are CP systems by nature.</p>
<hr />
<h2 id="the_lindy_effect_why_battle-tested_beats_new"><a href="#the_lindy_effect_why_battle-tested_beats_new" class="header-anchor">The Lindy Effect: Why &quot;Battle-Tested&quot; Beats &quot;New&quot;</a></h2>
<p>In engineering, there is a concept called <strong>the Lindy Effect</strong>:</p>
<blockquote>
<p>The longer a non-perishable thing &#40;like a technology or protocol&#41; has survived, the longer it is likely to survive in the future.</p>
</blockquote>
<p>This connects directly to CAP and partition tolerance. A system&#39;s ability to survive partitions isn&#39;t something you can prove in a lab—it&#39;s proven by <em>surviving real partitions</em> in production.</p>
<p><strong>Ethereum:</strong></p>
<ul>
<li><p>Has survived thousands of attacks over a decade</p>
</li>
<li><p>Has secured hundreds of billions of dollars</p>
</li>
<li><p>Has weathered network congestion, state bloat, and the Merge &#40;PoW→PoS transition&#41;</p>
</li>
<li><p>Its consistency guarantees have been tested by every adversarial condition the internet can throw at it</p>
</li>
</ul>
<p><strong>A &quot;New Tech&quot; from a 2025 research paper:</strong></p>
<ul>
<li><p>Might be 100x faster in benchmarks</p>
</li>
<li><p>Might have elegant proofs of consistency</p>
</li>
<li><p>But it hasn&#39;t survived a &quot;nuclear winter&quot; of real-world hacking, state-level adversaries, and network partitions at scale</p>
</li>
<li><p>Its CAP guarantees are <em>theoretical</em>, not <em>battle-tested</em></p>
</li>
</ul>
\[\underbrace{\text{Proven under fire}}_{\text{Ethereum, Bitcoin}} \gg \underbrace{\text{Proven on paper}}_{\text{New research}}\]
<p>For a nation storing its treasury, this asymmetry is everything. No central banker gets fired for choosing the technology that has already survived a decade of attacks. Plenty get fired for choosing the &quot;cutting-edge&quot; system that fails catastrophically on day 1.</p>
<hr />
<h2 id="the_modular_stack_having_your_cake_and_eating_it_too"><a href="#the_modular_stack_having_your_cake_and_eating_it_too" class="header-anchor">The Modular Stack: Having Your Cake and Eating It Too</a></h2>
<p>So if CP systems are slow but safe, and AP systems are fast but risky, how does a country in 2026 get both safety <em>and</em> speed?</p>
<p>The answer: <strong>the modular blockchain stack.</strong> Don&#39;t force one chain to do everything. Separate concerns:</p>
<pre><code class="language-julia">┌──────────────────────────────────────────────────┐
│  Layer 3: Application Layer                       │
│  &#40;DeFi, CBDCs, Trade Finance, Identity&#41;           │
├──────────────────────────────────────────────────┤
│  Layer 2: Execution Layer &#40;FAST&#41;                  │
│  Custom rollup: 100ms finality, high throughput   │
│  → AP-leaning: optimistic, fast responses         │
│  → But inherits L1 security via fraud/ZK proofs   │
├──────────────────────────────────────────────────┤
│  Layer 1: Settlement Layer &#40;SAFE&#41;                 │
│  Ethereum mainnet: ~13 min finality               │
│  → CP: slow, expensive, but CORRECT and FINAL     │
│  → The &quot;vault&quot; that everything anchors to          │
├──────────────────────────────────────────────────┤
│  Data Layer: Cheap Storage                        │
│  EigenDA, Celestia, or specialized DA layers       │
│  → Stores transaction history affordably           │
└──────────────────────────────────────────────────┘</code></pre>
<p><strong>How this solves CAP for sovereign use:</strong></p>
<ol>
<li><p><strong>Settlement Layer &#40;Ethereum&#41;:</strong> Pure CP. Slow, expensive, but when a state transition is finalized here, it is <em>immutable</em>. This is where the \(10B treasury transfer ultimately settles.

2. **Execution Layer (Custom L2):** Leans AP for day-to-day operations. Citizen payments clear in milliseconds. But every batch of transactions gets "anchored" back to L1, inheriting its security guarantees.

3. **Data Layer:** Stores the full transaction history cheaply so anyone can verify. Doesn't need to be fast—just available and correct.

$$\text{User experience: } \underbrace{\text{AP speed}}_{\text{Layer 2}} \quad + \quad \text{Security guarantee: } \underbrace{\text{CP finality}}_{\text{Layer 1}}$$

A country like the UAE or Singapore in 2026 doesn't just "use Ethereum." It builds a modular stack that gets the speed of a DAG or Hashgraph while keeping the battle-tested safety of the Ethereum mainnet.

**This is the key insight: Layer 2s don't replace the CAP tradeoff—they let you make different tradeoffs at different layers.**

Daily coffee purchases can tolerate AP (fast, occasionally inconsistent). Sovereign treasury settlement demands CP (slow, always correct). The modular stack gives you both, without compromising either.

---

## Why Ethereum's Moat Is Real

Putting it all together, Ethereum's competitive advantage isn't speed or cost—it's that it occupies the **CP settlement layer** position and has the Lindy Effect working in its favor:

1. **CAP Position:** Ethereum chose CP. It's slow and expensive *on purpose*. That's the point. It's the "vault," not the "cash register."

2. **Network Effects:** Every Layer 2 that builds on Ethereum *reinforces* its position as the settlement layer. More L2s → more economic activity → more security budget → harder to attack → more L2s. This is a flywheel.

3. **Lindy Effect:** 10+ years of surviving every attack. No other smart contract platform comes close. New chains can't buy this—they can only earn it by surviving.

4. **Institutional Trust:** When a central bank evaluates blockchain infrastructure, they're asking "can I trust this with my country's wealth for the next 50 years?" The answer requires CP guarantees + battle-tested track record. Ethereum has both.

$$\text{Ethereum's moat} = \underbrace{\text{CP guarantees}}_{\text{correct by design}} + \underbrace{\text{Lindy Effect}}_{\text{proven by time}} + \underbrace{\text{L2 flywheel}}_{\text{growing by network effects}}$$

The "old" tech wins in finance precisely *because* it's old. A nation-state doesn't want the shiny new chain with 100,000 TPS and 6 months of uptime. It wants the boring, slow, expensive chain that has never lost a dollar to a consensus failure in a decade.

That's not a weakness. That's a moat.

---

## The Takeaway

The CAP theorem isn't just an academic curiosity—it's the lens through which institutional finance evaluates every blockchain:

- **Retail traders** optimize for **A** (availability, speed, low fees) → they pick AP chains
- **Nation-states** optimize for **C** (consistency, finality, one truth) → they pick CP chains
- **The modular stack** lets you build AP experiences on top of CP foundations

The next time someone says "Ethereum is too slow and expensive," ask them: *slow and expensive compared to what?* Compared to Solana, yes. Compared to SWIFT (3–5 days, \)<hr /></p>
</li>
</ol>
<h2 id="why_ethereums_moat_is_real"><a href="#why_ethereums_moat_is_real" class="header-anchor">Why Ethereum&#39;s Moat Is Real</a></h2>
<p>Putting it all together, Ethereum&#39;s competitive advantage isn&#39;t speed or cost—it&#39;s that it occupies the <strong>CP settlement layer</strong> position and has the Lindy Effect working in its favor:</p>
<ol>
<li><p><strong>CAP Position:</strong> Ethereum chose CP. It&#39;s slow and expensive <em>on purpose</em>. That&#39;s the point. It&#39;s the &quot;vault,&quot; not the &quot;cash register.&quot;</p>
</li>
<li><p><strong>Network Effects:</strong> Every Layer 2 that builds on Ethereum <em>reinforces</em> its position as the settlement layer. More L2s → more economic activity → more security budget → harder to attack → more L2s. This is a flywheel.</p>
</li>
<li><p><strong>Lindy Effect:</strong> 10&#43; years of surviving every attack. No other smart contract platform comes close. New chains can&#39;t buy this—they can only earn it by surviving.</p>
</li>
<li><p><strong>Institutional Trust:</strong> When a central bank evaluates blockchain infrastructure, they&#39;re asking &quot;can I trust this with my country&#39;s wealth for the next 50 years?&quot; The answer requires CP guarantees &#43; battle-tested track record. Ethereum has both.</p>
</li>
</ol>
&#36;\text&#123;Ethereum&#39;s moat&#125; &#61; \underbrace&#123;\text&#123;CP guarantees}}_&#123;\text&#123;correct by design}} &#43; \underbrace&#123;\text&#123;Lindy Effect}}_&#123;\text&#123;proven by time}} &#43; \underbrace&#123;\text&#123;L2 flywheel}}_&#123;\text&#123;growing by network effects}}&#36;
<p>The &quot;old&quot; tech wins in finance precisely <em>because</em> it&#39;s old. A nation-state doesn&#39;t want the shiny new chain with 100,000 TPS and 6 months of uptime. It wants the boring, slow, expensive chain that has never lost a dollar to a consensus failure in a decade.</p>
<p>That&#39;s not a weakness. That&#39;s a moat.</p>
<hr />
<h2 id="the_takeaway"><a href="#the_takeaway" class="header-anchor">The Takeaway</a></h2>
<p>The CAP theorem isn&#39;t just an academic curiosity—it&#39;s the lens through which institutional finance evaluates every blockchain:</p>
<ul>
<li><p><strong>Retail traders</strong> optimize for <strong>A</strong> &#40;availability, speed, low fees&#41; → they pick AP chains</p>
</li>
<li><p><strong>Nation-states</strong> optimize for <strong>C</strong> &#40;consistency, finality, one truth&#41; → they pick CP chains</p>
</li>
<li><p><strong>The modular stack</strong> lets you build AP experiences on top of CP foundations</p>
</li>
</ul>
<p>The next time someone says &quot;Ethereum is too slow and expensive,&quot; ask them: <em>slow and expensive compared to what?</em> Compared to Solana, yes. Compared to SWIFT &#40;3–5 days, 25–50 per transfer&#41;, Ethereum is blazingly fast, radically cheap, and infinitely more transparent.</p>
<p>The &quot;right&quot; blockchain depends entirely on what you&#39;re optimizing for. And when you&#39;re optimizing for &quot;my country&#39;s treasury doesn&#39;t disappear,&quot; slow and boring wins every time.</p>
<div class="page-foot">
    Contact me by <a href="mailto:skchu@wustl.edu">E-mail</a> | <a href="https://github.com/kchu25">Github</a> | <a href="https://www.linkedin.com/in/kchu1/">Linkedin</a>
    <br>
    This work is licensed under <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a>.  Last modified: February 14, 2026.
    <br>
    Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia language</a>.
</div>
</div><!-- CONTENT ENDS HERE -->
    
        <script src="/libs/katex/katex.min.js"></script>
<script src="/libs/katex/contrib/auto-render.min.js"></script>
<script>renderMathInElement(document.body)</script>

    
    
        <script src="/libs/highlight/highlight.min.js"></script>
<script>
// Register Solidity language for highlight.js
hljs.registerLanguage('solidity', function(hljs) {
  return {
    keywords: {
      keyword: 'contract interface library pragma import using struct enum event modifier function returns return require revert assert emit new delete if else for while do break continue try catch throw this super constructor fallback receive ' +
                'public private internal external pure view payable virtual override constant immutable anonymous indexed storage memory calldata',
      literal: 'true false wei gwei ether seconds minutes hours days weeks years',
      built_in: 'msg block tx abi now sender value gas data origin gasprice blockhash gasleft address uint int bytes string bool mapping'
    },
    contains: [
      hljs.C_LINE_COMMENT_MODE,
      hljs.C_BLOCK_COMMENT_MODE,
      hljs.QUOTE_STRING_MODE,
      hljs.APOS_STRING_MODE,
      {
        className: 'number',
        begin: '\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)',
        relevance: 0
      },
      {
        className: 'type',
        begin: '\\b(uint|int|bytes|byte|string|address|bool|ufixed|fixed)(\\d+x\\d+|\\d+)?\\b'
      },
      {
        className: 'function',
        beginKeywords: 'function modifier event constructor fallback receive',
        end: '[{;]',
        excludeEnd: true,
        contains: [
          {
            className: 'title',
            begin: '[A-Za-z$_][0-9A-Za-z$_]*',
            relevance: 0
          },
          {
            className: 'params',
            begin: '\\(', end: '\\)',
            contains: [hljs.C_LINE_COMMENT_MODE, hljs.C_BLOCK_COMMENT_MODE]
          }
        ]
      }
    ]
  };
});

hljs.highlightAll();
hljs.configure({tabReplace: '    '});
</script>


    
  </body>
</html>

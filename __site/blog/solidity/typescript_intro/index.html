<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700;900&display=swap" rel="stylesheet">
  <style>
    @font-face {
      font-family: 'BPdots';
      src: url('/blockchains/assets/fonts/BPdots/BPdots.otf') format('opentype');
      font-weight: normal;
      font-style: normal;
    }
    @font-face {
      font-family: 'BPdots';
      src: url('/blockchains/assets/fonts/BPdots/BPdotsBold.otf') format('opentype');
      font-weight: bold;
      font-style: normal;
    }
  </style>
  
   <link rel="stylesheet" href="/libs/highlight/styles/atom-one-dark.min.css">
   
  <link rel="stylesheet" href="/css/franklin.css">
<link rel="stylesheet" href="/css/hypertext.css">
<link rel="icon" href="/assets/favicon.png">

   <title>TypeScript for Smart Contract Development</title>  
</head>
<body>
<header>
  <h1 style="color:#283747; font-family:'BPdots', monospace; font-size:2.5em; font-weight:normal; letter-spacing:0.1em">blockchains</h1>
  <nav>
    <a href="/" class="current">Tags</a>
  | <a href="/blog/" >Notes</a>
  <hr/>
  </nav>
</header>


<!-- Content appended here -->
<div class="franklin-content"><h1 id="typescript_for_smart_contract_development"><a href="#typescript_for_smart_contract_development" class="header-anchor">TypeScript for Smart Contract Development</a></h1>
<p><strong>TL;DR:</strong> TypeScript is JavaScript &#43; optional static types. In smart contract development, it catches bugs <em>before</em> you deploy &#40;where fixes cost money&#41;. This post covers syntax, motivation, and practical patterns for Hardhat &#43; Ethers.js.</p>
<hr />
<h2 id="why_typescript_and_why_now"><a href="#why_typescript_and_why_now" class="header-anchor">Why TypeScript &#40;and Why Now&#41;?</a></h2>
<h3 id="the_problem_javascripts_silent_failures"><a href="#the_problem_javascripts_silent_failures" class="header-anchor">The Problem: JavaScript&#39;s Silent Failures</a></h3>
<p>JavaScript lets you write anything and will silently fail at runtime:</p>
<pre><code class="language-javascript">// JavaScript - no error until you run it
const amount &#61; &quot;100&quot;;  // Oops, this is a string
const total &#61; amount &#43; 50;  // &quot;10050&quot; &#40;string concatenation, not addition&#33;&#41;

const contract &#61; await ethers.getContractFactory&#40;&quot;Counter&quot;&#41;;
// Typo: &quot;Counter&quot; doesn&#39;t exist? Error only when code runs&#33;</code></pre>
<p>In <strong>smart contracts</strong>, runtime errors are catastrophic:</p>
<ul>
<li><p>You can&#39;t debug live on mainnet</p>
</li>
<li><p>Bugs cost real money &#40;gas fees, user losses&#41;</p>
</li>
<li><p>Deployed code is immutable—you can&#39;t patch it</p>
</li>
</ul>
<p>TypeScript catches these <em>at development time</em>:</p>
<pre><code class="language-typescript">// TypeScript - error shown in VSCode immediately
const amount: string &#61; &quot;100&quot;;
const total &#61; amount &#43; 50;  // ❌ Error: &quot;cannot add string &#43; number&quot;

const contract &#61; await ethers.getContractFactory&#40;&quot;Counter&quot;&#41;;
// ✅ Type-safe: ethers knows what methods exist</code></pre>
<h3 id="the_motivation_types_are_documentation"><a href="#the_motivation_types_are_documentation" class="header-anchor">The Motivation: Types Are Documentation</a></h3>
<p>Good types act as <strong>live documentation</strong>:</p>
<pre><code class="language-typescript">// JavaScript - what does this function expect?
function transfer&#40;to, amount&#41; &#123;
  // Is to a string? Address object? Number?
  // Is amount a BigNumber? Regular number? String?
&#125;

// TypeScript - types make it crystal clear
function transfer&#40;to: string, amount: BigNumber&#41;: Promise&lt;TransactionResponse&gt; &#123;
  // to must be a string &#40;Ethereum address&#41;
  // amount must be a BigNumber &#40;to avoid precision loss&#41;
  // Returns a transaction response
&#125;</code></pre>
<h3 id="where_typescript_shines_in_smart_contracts"><a href="#where_typescript_shines_in_smart_contracts" class="header-anchor">Where TypeScript Shines in Smart Contracts</a></h3>
<ol>
<li><p><strong>Type Safety for Ethers.js</strong> — the library has thousands of edge cases. Types catch them early.</p>
</li>
<li><p><strong>Preventing Precision Errors</strong> — crypto uses big integers &#40;256-bit numbers&#41;. TypeScript enforces BigNumber usage.</p>
</li>
<li><p><strong>Deployment Safety</strong> — catch missing/wrong contract names, function arguments before deploying.</p>
</li>
<li><p><strong>Test Reliability</strong> — type-checked tests are more trustworthy.</p>
</li>
<li><p><strong>IDE Autocomplete</strong> — VSCode knows exactly what methods/properties exist.</p>
</li>
</ol>
<hr />
<h2 id="part_1_core_typescript_syntax"><a href="#part_1_core_typescript_syntax" class="header-anchor">Part 1: Core TypeScript Syntax</a></h2>
<h3 id="basic_types"><a href="#basic_types" class="header-anchor">Basic Types</a></h3>
<pre><code class="language-typescript">// Primitives
const name: string &#61; &quot;Alice&quot;;
const age: number &#61; 30;
const active: boolean &#61; true;
const nothing: null &#61; null;
const undefined_value: undefined &#61; undefined;

// Arrays
const numbers: number&#91;&#93; &#61; &#91;1, 2, 3&#93;;
const strings: Array&lt;string&gt; &#61; &#91;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#93;;  // Alternative syntax

// Union types &#40;multiple possibilities&#41;
const id: string | number &#61; 123;  // Can be string OR number
const status: &quot;pending&quot; | &quot;completed&quot; | &quot;failed&quot; &#61; &quot;pending&quot;;  // Literal type

// Any &#40;escape hatch - avoid when possible&#41;
const unknown_value: any &#61; Math.random&#40;&#41;;  // Disables type checking</code></pre>
<h3 id="functions"><a href="#functions" class="header-anchor">Functions</a></h3>
<pre><code class="language-typescript">// Function with typed parameters and return type
function add&#40;a: number, b: number&#41;: number &#123;
  return a &#43; b;
&#125;

// Optional parameters &#40;?&#41;
function greet&#40;name: string, age?: number&#41;: void &#123;
  console.log&#40;&#96;Hello, &#36;&#123;name&#125;&#96;&#41;;
  // age might be undefined
&#125;

// Default parameters
function multiply&#40;a: number, b: number &#61; 2&#41;: number &#123;
  return a * b;
&#125;

// Arrow functions
const square &#61; &#40;x: number&#41;: number &#61;&gt; x * x;

// Function types &#40;what the function signature looks like&#41;
type MathOperation &#61; &#40;a: number, b: number&#41; &#61;&gt; number;
const myFunction: MathOperation &#61; &#40;x, y&#41; &#61;&gt; x &#43; y;</code></pre>
<h3 id="objects_and_interfaces"><a href="#objects_and_interfaces" class="header-anchor">Objects and Interfaces</a></h3>
<pre><code class="language-typescript">// Object type
const user: &#123; name: string; age: number &#125; &#61; &#123;
  name: &quot;Alice&quot;,
  age: 30,
&#125;;

// Interface &#40;preferred for complex objects&#41;
interface User &#123;
  name: string;
  age: number;
  email?: string;  // Optional property
&#125;

const alice: User &#61; &#123;
  name: &quot;Alice&quot;,
  age: 30,
  // email is optional, so we can omit it
&#125;;

// Readonly properties
interface Config &#123;
  readonly apiKey: string;
  readonly timeout: number;
&#125;

const config: Config &#61; &#123; apiKey: &quot;secret&quot;, timeout: 5000 &#125;;
// config.apiKey &#61; &quot;newkey&quot;;  // ❌ Error: readonly</code></pre>
<h3 id="generics_reusable_type_containers"><a href="#generics_reusable_type_containers" class="header-anchor">Generics &#40;Reusable Type Containers&#41;</a></h3>
<p>Generics let you write code that works with <em>any</em> type while staying type-safe:</p>
<pre><code class="language-typescript">// Without generics &#40;loses type information&#41;
function getFirstElement&#40;arr: any&#91;&#93;&#41;: any &#123;
  return arr&#91;0&#93;;  // Return type is unknown
&#125;

// With generics &#40;preserves type information&#41;
function getFirstElement&lt;T&gt;&#40;arr: T&#91;&#93;&#41;: T &#123;
  return arr&#91;0&#93;;  // Return type matches input type
&#125;

const firstNum &#61; getFirstElement&#40;&#91;1, 2, 3&#93;&#41;;  // firstNum: number
const firstStr &#61; getFirstElement&#40;&#91;&quot;a&quot;, &quot;b&quot;&#93;&#41;;  // firstStr: string

// Generic interfaces &#40;useful for smart contract ABIs&#41;
interface ApiResponse&lt;T&gt; &#123;
  status: number;
  data: T;
&#125;

const userResponse: ApiResponse&lt;User&gt; &#61; &#123;
  status: 200,
  data: &#123; name: &quot;Alice&quot;, age: 30 &#125;,
&#125;;</code></pre>
<h3 id="classes"><a href="#classes" class="header-anchor">Classes</a></h3>
<pre><code class="language-typescript">class Counter &#123;
  // Properties with types
  private count: number &#61; 0;
  public owner: string;

  // Constructor with type-checked parameters
  constructor&#40;initialOwner: string&#41; &#123;
    this.owner &#61; initialOwner;
  &#125;

  // Method with return type
  public increment&#40;&#41;: void &#123;
    this.count &#43;&#61; 1;
  &#125;

  public getCount&#40;&#41;: number &#123;
    return this.count;
  &#125;

  // Static method &#40;belongs to class, not instance&#41;
  static create&#40;owner: string&#41;: Counter &#123;
    return new Counter&#40;owner&#41;;
  &#125;
&#125;

const counter &#61; new Counter&#40;&quot;Alice&quot;&#41;;
counter.increment&#40;&#41;;
console.log&#40;counter.getCount&#40;&#41;&#41;;  // 1</code></pre>
<h3 id="type_aliases_vs_interfaces"><a href="#type_aliases_vs_interfaces" class="header-anchor">Type Aliases vs Interfaces</a></h3>
<p>Both define custom types, but they differ subtly:</p>
<pre><code class="language-typescript">// Type alias &#40;use for unions, primitives, or complex types&#41;
type Status &#61; &quot;pending&quot; | &quot;completed&quot; | &quot;failed&quot;;
type MaybeString &#61; string | null;
type ApiResponse &#61; &#123; status: number; data: string &#125;;

// Interface &#40;use for objects, especially if you might extend them&#41;
interface User &#123;
  name: string;
  age: number;
&#125;

interface Admin extends User &#123;
  permissions: string&#91;&#93;;
&#125;

// General rule: use Interface for objects, Type for everything else</code></pre>
<hr />
<h2 id="part_2_typescript_in_hardhat_practical_examples"><a href="#part_2_typescript_in_hardhat_practical_examples" class="header-anchor">Part 2: TypeScript in Hardhat &#40;Practical Examples&#41;</a></h2>
<h3 id="example_1_type-safe_contract_interaction"><a href="#example_1_type-safe_contract_interaction" class="header-anchor">Example 1: Type-Safe Contract Interaction</a></h3>
<pre><code class="language-typescript">// test/Counter.test.ts
import &#123; expect &#125; from &quot;chai&quot;;
import &#123; ethers &#125; from &quot;hardhat&quot;;
import &#123; Counter &#125; from &quot;../typechain-types&quot;;  // Auto-generated types&#33;

describe&#40;&quot;Counter&quot;, function &#40;&#41; &#123;
  let counter: Counter;  // counter has full type information

  beforeEach&#40;async function &#40;&#41; &#123;
    // ethers.getContractFactory&#40;&#41; returns typed contract
    const CounterFactory &#61; await ethers.getContractFactory&#40;&quot;Counter&quot;&#41;;
    counter &#61; await CounterFactory.deploy&#40;&#41;;  // counter: Counter &#40;typed&#33;&#41;
  &#125;&#41;;

  it&#40;&quot;should increment&quot;, async function &#40;&#41; &#123;
    // TypeScript knows counter has increment&#40;&#41; method
    await counter.increment&#40;&#41;;

    // TypeScript knows getCount&#40;&#41; returns a BigNumber
    const count &#61; await counter.getCount&#40;&#41;;
    expect&#40;count&#41;.to.equal&#40;1&#41;;
  &#125;&#41;;

  it&#40;&quot;should revert on underflow&quot;, async function &#40;&#41; &#123;
    // TypeScript knows decrement&#40;&#41; exists and what it throws
    await expect&#40;counter.decrement&#40;&#41;&#41;.to.be.revertedWith&#40;
      &quot;Count cannot be negative&quot;
    &#41;;
  &#125;&#41;;
&#125;&#41;;</code></pre>
<h3 id="example_2_helper_functions_with_types"><a href="#example_2_helper_functions_with_types" class="header-anchor">Example 2: Helper Functions with Types</a></h3>
<pre><code class="language-typescript">// scripts/deploy.ts
import &#123; ethers &#125; from &quot;hardhat&quot;;
import &#123; Counter &#125; from &quot;../typechain-types&quot;;

// Function with explicit types
async function deployCounter&#40;&#41;: Promise&lt;Counter&gt; &#123;
  const CounterFactory &#61; await ethers.getContractFactory&#40;&quot;Counter&quot;&#41;;
  const counter &#61; await CounterFactory.deploy&#40;&#41;;
  return counter;
&#125;

// Type-safe interaction
async function main&#40;&#41;: Promise&lt;void&gt; &#123;
  const counter: Counter &#61; await deployCounter&#40;&#41;;

  // TypeScript knows counter.increment&#40;&#41; exists
  const tx &#61; await counter.increment&#40;&#41;;
  await tx.wait&#40;&#41;;

  // TypeScript knows getCount&#40;&#41; returns a BigNumber
  const count &#61; await counter.getCount&#40;&#41;;
  console.log&#40;&quot;Count:&quot;, count.toString&#40;&#41;&#41;;
&#125;

main&#40;&#41;.catch&#40;&#40;error&#41; &#61;&gt; &#123;
  console.error&#40;error&#41;;
  process.exitCode &#61; 1;
&#125;&#41;;</code></pre>
<h3 id="example_3_configuration_with_types"><a href="#example_3_configuration_with_types" class="header-anchor">Example 3: Configuration with Types</a></h3>
<pre><code class="language-typescript">// hardhat.config.ts
import &#123; HardhatUserConfig &#125; from &quot;hardhat/config&quot;;
import &quot;@nomicfoundation/hardhat-toolbox&quot;;

const config: HardhatUserConfig &#61; &#123;
  solidity: &quot;0.8.24&quot;,
  networks: &#123;
    hardhat: &#123;
      // type-checked
    &#125;,
    sepolia: &#123;
      url: process.env.SEPOLIA_RPC_URL || &quot;&quot;,
      accounts: process.env.PRIVATE_KEY ? &#91;process.env.PRIVATE_KEY&#93; : &#91;&#93;,
    &#125;,
  &#125;,
&#125;;

export default config;</code></pre>
<h3 id="auto-generated_contract_types_typechain"><a href="#auto-generated_contract_types_typechain" class="header-anchor">Auto-Generated Contract Types &#40;typechain&#41;</a></h3>
<p>When you compile Solidity contracts, Hardhat generates TypeScript types automatically:</p>
<pre><code class="language-bash">npm test  # This also generates types</code></pre>
<p>Creates <code>typechain-types/Counter.ts</code>:</p>
<pre><code class="language-typescript">// Auto-generated &#40;don&#39;t edit&#41;
export interface Counter extends BaseContract &#123;
  increment&#40;&#41;: Promise&lt;ContractTransactionResponse | null&gt;;
  decrement&#40;&#41;: Promise&lt;ContractTransactionResponse | null&gt;;
  getCount&#40;&#41;: Promise&lt;BigNumberish&gt;;
&#125;</code></pre>
<p>Now you get <strong>full autocomplete</strong> for your contracts in VSCode&#33;</p>
<hr />
<h2 id="part_3_smart_contract-specific_patterns"><a href="#part_3_smart_contract-specific_patterns" class="header-anchor">Part 3: Smart Contract-Specific Patterns</a></h2>
<h3 id="pattern_1_bignumber_handling"><a href="#pattern_1_bignumber_handling" class="header-anchor">Pattern 1: BigNumber Handling</a></h3>
<p>Ethereum uses 256-bit integers. TypeScript helps enforce this:</p>
<pre><code class="language-typescript">import &#123; BigNumber &#125; from &quot;ethers&quot;;

// ❌ Wrong: JavaScript number loses precision
const balance: number &#61; 1000000000000000000;

// ✅ Right: Use BigNumber
const balance: BigNumber &#61; ethers.BigNumber.from&#40;&quot;1000000000000000000&quot;&#41;;

// ✅ Also right: String representation
const balance2 &#61; ethers.utils.parseEther&#40;&quot;1.0&quot;&#41;;  // Returns BigNumber

// Convert back to human-readable
console.log&#40;ethers.utils.formatEther&#40;balance&#41;&#41;;  // &quot;1.0&quot;</code></pre>
<h3 id="pattern_2_address_type_safety"><a href="#pattern_2_address_type_safety" class="header-anchor">Pattern 2: Address Type Safety</a></h3>
<pre><code class="language-typescript">// Define a branded type for addresses &#40;ensures correctness&#41;
type Address &#61; string &amp; &#123; readonly __brand: &quot;Address&quot; &#125;;

function isAddress&#40;value: string&#41;: value is Address &#123;
  return ethers.utils.isAddress&#40;value&#41;;
&#125;

// Now you can use it
function transfer&#40;to: Address, amount: BigNumber&#41;: Promise&lt;void&gt; &#123;
  // to must be a valid address &#40;compiler enforces this at call site&#41;
&#125;

// At call site:
const recipient &#61; &quot;0x742d35Cc6634C0532925a3b844Bc9e7595f42bE3&quot;;
if &#40;isAddress&#40;recipient&#41;&#41; &#123;
  await transfer&#40;recipient, ethers.utils.parseEther&#40;&quot;1.0&quot;&#41;&#41;;
&#125;</code></pre>
<h3 id="pattern_3_event_typing"><a href="#pattern_3_event_typing" class="header-anchor">Pattern 3: Event Typing</a></h3>
<pre><code class="language-typescript">interface TransferEvent &#123;
  from: string;
  to: string;
  amount: BigNumber;
&#125;

async function watchTransfers&#40;contract: IERC20&#41;: Promise&lt;void&gt; &#123;
  contract.on&#40;&quot;Transfer&quot;, &#40;from: string, to: string, amount: BigNumber&#41; &#61;&gt; &#123;
    const event: TransferEvent &#61; &#123; from, to, amount &#125;;
    console.log&#40;&#96;Transfer from &#36;&#123;event.from&#125; to &#36;&#123;event.to&#125;: &#36;&#123;event.amount&#125;&#96;&#41;;
  &#125;&#41;;
&#125;</code></pre>
<h3 id="pattern_4_gas_estimation_with_types"><a href="#pattern_4_gas_estimation_with_types" class="header-anchor">Pattern 4: Gas Estimation with Types</a></h3>
<pre><code class="language-typescript">import &#123; BigNumber, ContractTransaction &#125; from &quot;ethers&quot;;

async function estimateAndSend&#40;
  contract: Counter
&#41;: Promise&lt;ContractTransaction&gt; &#123;
  // Estimate gas &#40;returns BigNumber&#41;
  const gasEstimate: BigNumber &#61; await contract.estimateGas.increment&#40;&#41;;

  // Add 10&#37; buffer
  const gasLimit: BigNumber &#61; gasEstimate.mul&#40;110&#41;.div&#40;100&#41;;

  // Send with explicit gas limit &#40;type-safe&#41;
  const tx: ContractTransaction &#61; await contract.increment&#40;&#123;
    gasLimit,
  &#125;&#41;;

  return tx;
&#125;</code></pre>
<hr />
<h2 id="part_4_common_typescript_patterns_for_smart_contracts"><a href="#part_4_common_typescript_patterns_for_smart_contracts" class="header-anchor">Part 4: Common TypeScript Patterns for Smart Contracts</a></h2>
<h3 id="utility_types"><a href="#utility_types" class="header-anchor">Utility Types</a></h3>
<p>TypeScript provides helpful built-in type transformations:</p>
<pre><code class="language-typescript">// Partial&lt;T&gt; - make all properties optional
interface ContractConfig &#123;
  address: string;
  abi: any;
  signer: Signer;
&#125;

function updateConfig&#40;updates: Partial&lt;ContractConfig&gt;&#41;: void &#123;
  // updates can have any subset of ContractConfig properties
&#125;

// Record&lt;K, V&gt; - map from keys to values
type ContractRegistry &#61; Record&lt;string, Contract&gt;;
const contracts: ContractRegistry &#61; &#123;
  counter: counterInstance,
  token: tokenInstance,
&#125;;

// Omit&lt;T, K&gt; - remove properties from type
type PublicContract &#61; Omit&lt;Contract, &quot;privateProperty&quot;&gt;;

// Pick&lt;T, K&gt; - keep only specific properties
type MinimalConfig &#61; Pick&lt;ContractConfig, &quot;address&quot; | &quot;abi&quot;&gt;;</code></pre>
<h3 id="error_handling_with_types"><a href="#error_handling_with_types" class="header-anchor">Error Handling with Types</a></h3>
<pre><code class="language-typescript">// Define error types
interface DeploymentError &#123;
  type: &quot;deployment&quot;;
  message: string;
  gasUsed?: BigNumber;
&#125;

interface TransactionError &#123;
  type: &quot;transaction&quot;;
  txHash: string;
  reason: string;
&#125;

type ContractError &#61; DeploymentError | TransactionError;

// Type-safe error handler
function handleError&#40;error: ContractError&#41;: void &#123;
  if &#40;error.type &#61;&#61;&#61; &quot;deployment&quot;&#41; &#123;
    console.error&#40;&quot;Deployment failed:&quot;, error.message&#41;;
    if &#40;error.gasUsed&#41; &#123;
      console.error&#40;&quot;Gas used:&quot;, error.gasUsed.toString&#40;&#41;&#41;;
    &#125;
  &#125; else &#123;
    console.error&#40;&quot;Transaction failed:&quot;, error.reason&#41;;
    console.error&#40;&quot;Hash:&quot;, error.txHash&#41;;
  &#125;
&#125;</code></pre>
<h3 id="asyncawait_with_types"><a href="#asyncawait_with_types" class="header-anchor">Async/Await with Types</a></h3>
<pre><code class="language-typescript">// Explicitly type async functions
async function deployAndVerify&#40;contractName: string&#41;: Promise&lt;Contract&gt; &#123;
  const contract &#61; await ethers.getContractFactory&#40;contractName&#41;;
  const deployed &#61; await contract.deploy&#40;&#41;;
  await deployed.deployed&#40;&#41;;  // Wait for deployment
  return deployed;
&#125;

// Async array operations
async function deployMultiple&#40;names: string&#91;&#93;&#41;: Promise&lt;Contract&#91;&#93;&gt; &#123;
  const contracts &#61; await Promise.all&#40;
    names.map&#40;&#40;name&#41; &#61;&gt; deployAndVerify&#40;name&#41;&#41;
  &#41;;
  return contracts;
&#125;</code></pre>
<hr />
<h2 id="part_5_typescript_configuration"><a href="#part_5_typescript_configuration" class="header-anchor">Part 5: TypeScript Configuration</a></h2>
<h3 id="tsconfigjson_the_config_file"><a href="#tsconfigjson_the_config_file" class="header-anchor">tsconfig.json &#40;the config file&#41;</a></h3>
<p>Hardhat creates this automatically, but here&#39;s what matters:</p>
<pre><code class="language-json">&#123;
  &quot;compilerOptions&quot;: &#123;
    &quot;target&quot;: &quot;ES2020&quot;,           // Modern JavaScript
    &quot;module&quot;: &quot;commonjs&quot;,         // Node.js modules
    &quot;lib&quot;: &#91;&quot;ES2020&quot;&#93;,            // What APIs are available
    &quot;outDir&quot;: &quot;./dist&quot;,           // Where to put compiled JS
    &quot;rootDir&quot;: &quot;./&quot;,              // Where to find .ts files
    &quot;strict&quot;: true,               // Enable ALL type checking
    &quot;esModuleInterop&quot;: true,      // Import CommonJS as ES modules
    &quot;skipLibCheck&quot;: true,         // Don&#39;t check node_modules
    &quot;forceConsistentCasingInFileNames&quot;: true,  // Catch file name typos
    &quot;resolveJsonModule&quot;: true,    // Allow importing .json files
    &quot;moduleResolution&quot;: &quot;node&quot;    // Use Node.js module resolution
  &#125;,
  &quot;include&quot;: &#91;
    &quot;test/**/*.ts&quot;,
    &quot;scripts/**/*.ts&quot;,
    &quot;hardhat.config.ts&quot;
  &#93;,
  &quot;exclude&quot;: &#91;&quot;node_modules&quot;&#93;
&#125;</code></pre>
<p>Key setting: <strong><code>&quot;strict&quot;: true</code></strong> enables maximum type checking. This catches the most bugs.</p>
<hr />
<h2 id="part_6_migrating_from_javascript"><a href="#part_6_migrating_from_javascript" class="header-anchor">Part 6: Migrating from JavaScript</a></h2>
<p>If you already have a JavaScript Hardhat project, converting to TypeScript is easy:</p>
<h3 id="step_1_rename_files"><a href="#step_1_rename_files" class="header-anchor">Step 1: Rename Files</a></h3>
<pre><code class="language-bash"># Rename all .js files to .ts
mv hardhat.config.js hardhat.config.ts
mv test/*.js test/*.ts
mv scripts/*.js scripts/*.ts</code></pre>
<h3 id="step_2_add_tsconfigjson_if_not_present"><a href="#step_2_add_tsconfigjson_if_not_present" class="header-anchor">Step 2: Add tsconfig.json &#40;if not present&#41;</a></h3>
<p>Hardhat creates this, but if you&#39;re manually migrating:</p>
<pre><code class="language-bash">npx hardhat init</code></pre>
<h3 id="step_3_install_types"><a href="#step_3_install_types" class="header-anchor">Step 3: Install Types</a></h3>
<pre><code class="language-bash">npm install --save-dev @types/node</code></pre>
<h3 id="step_4_add_type_annotations_gradually"><a href="#step_4_add_type_annotations_gradually" class="header-anchor">Step 4: Add Type Annotations &#40;Gradually&#41;</a></h3>
<p>You don&#39;t have to type everything at once. Start with functions:</p>
<pre><code class="language-typescript">// Before: JavaScript
function deploy&#40;name&#41; &#123;
  return ethers.getContractFactory&#40;name&#41;.then&#40;f &#61;&gt; f.deploy&#40;&#41;&#41;;
&#125;

// After: TypeScript
function deploy&#40;name: string&#41;: Promise&lt;Contract&gt; &#123;
  return ethers.getContractFactory&#40;name&#41;.then&#40;f &#61;&gt; f.deploy&#40;&#41;&#41;;
&#125;</code></pre>
<h3 id="step_5_generate_contract_types"><a href="#step_5_generate_contract_types" class="header-anchor">Step 5: Generate Contract Types</a></h3>
<pre><code class="language-bash">npm test  # This compiles Solidity and generates typechain types</code></pre>
<p>Now your <code>.ts</code> files can import typed contracts:</p>
<pre><code class="language-typescript">import &#123; Counter &#125; from &quot;../typechain-types&quot;;</code></pre>
<hr />
<h2 id="part_7_debugging_typescript"><a href="#part_7_debugging_typescript" class="header-anchor">Part 7: Debugging TypeScript</a></h2>
<h3 id="seeing_the_error"><a href="#seeing_the_error" class="header-anchor">Seeing the Error</a></h3>
<p>TypeScript shows errors in VSCode&#39;s &quot;Problems&quot; panel &#40;Ctrl&#43;Shift&#43;M&#41;:</p>
<pre><code class="language-julia">test/Counter.test.ts:10:5 - error TS2345:
Argument of type &#39;string&#39; is not assignable to parameter of type &#39;number&#39;.</code></pre>
<h3 id="checking_without_running"><a href="#checking_without_running" class="header-anchor">Checking Without Running</a></h3>
<pre><code class="language-bash"># Check types without compiling/running
npx tsc --noEmit</code></pre>
<h3 id="getting_better_error_messages"><a href="#getting_better_error_messages" class="header-anchor">Getting Better Error Messages</a></h3>
<p>Add this to <code>tsconfig.json</code>:</p>
<pre><code class="language-json">&#123;
  &quot;compilerOptions&quot;: &#123;
    &quot;pretty&quot;: true,
    &quot;noEmitOnError&quot;: true
  &#125;
&#125;</code></pre>
<hr />
<h2 id="part_8_when_not_to_use_types"><a href="#part_8_when_not_to_use_types" class="header-anchor">Part 8: When NOT to Use Types</a></h2>
<p>Sometimes types are overkill:</p>
<pre><code class="language-typescript">// ❌ Unnecessary - obvious what this is
const name: string &#61; &quot;Alice&quot;;

// ✅ Good - helps when type isn&#39;t obvious
const result: TransactionResponse | null &#61; await tx.wait&#40;&#41;;

// ❌ Unnecessary - just use any for truly unknown data
const config: any &#61; JSON.parse&#40;configFile&#41;;

// ✅ Better - define the shape
interface ConfigShape &#123;
  rpcUrl: string;
  gasPrice: BigNumber;
&#125;
const config: ConfigShape &#61; JSON.parse&#40;configFile&#41;;</code></pre>
<p><strong>Rule of thumb:</strong> Use types when:</p>
<ol>
<li><p>The type isn&#39;t obvious from context</p>
</li>
<li><p>The code will be used by others</p>
</li>
<li><p>The mistake is costly &#40;sending transactions, deploying contracts&#41;</p>
</li>
</ol>
<hr />
<h2 id="part_9_quick_reference"><a href="#part_9_quick_reference" class="header-anchor">Part 9: Quick Reference</a></h2>
<h3 id="type_annotations"><a href="#type_annotations" class="header-anchor">Type Annotations</a></h3>
<pre><code class="language-typescript">// Variable
const x: number &#61; 5;

// Function parameter and return
function add&#40;a: number, b: number&#41;: number &#123;
  return a &#43; b;
&#125;

// Arrow function
const square &#61; &#40;x: number&#41;: number &#61;&gt; x * x;

// Array
const numbers: number&#91;&#93; &#61; &#91;1, 2, 3&#93;;

// Object/Interface
interface User &#123;
  name: string;
  age: number;
&#125;
const user: User &#61; &#123; name: &quot;Alice&quot;, age: 30 &#125;;

// Union
type Status &#61; &quot;pending&quot; | &quot;done&quot; | &quot;failed&quot;;

// Generic
function first&lt;T&gt;&#40;arr: T&#91;&#93;&#41;: T &#123;
  return arr&#91;0&#93;;
&#125;</code></pre>
<h3 id="common_errors_and_fixes"><a href="#common_errors_and_fixes" class="header-anchor">Common Errors and Fixes</a></h3>
<table><tr><th align="right">Error</th><th align="right">Cause</th><th align="right">Fix</th></tr><tr><td align="right"><code>Type &#39;string&#39; is not assignable to type &#39;number&#39;</code></td><td align="right">Wrong type</td><td align="right">Check the variable type</td></tr><tr><td align="right"><code>Property &#39;foo&#39; does not exist on type &#39;Bar&#39;</code></td><td align="right">Typo or missing property</td><td align="right">Check spelling, add property to interface</td></tr><tr><td align="right"><code>Cannot find name &#39;MyType&#39;</code></td><td align="right">Type not imported</td><td align="right">Import or define the type</td></tr><tr><td align="right"><code>Object is of type &#39;unknown&#39;</code></td><td align="right">Variable type is unknown</td><td align="right">Add type annotation or type guard</td></tr></table>
<h3 id="hardhat_typescript_commands"><a href="#hardhat_typescript_commands" class="header-anchor">Hardhat &#43; TypeScript Commands</a></h3>
<pre><code class="language-bash"># Type-check without compiling
npx hardhat compile

# Run tests &#40;compiles TypeScript&#41;
npx hardhat test

# Run a script
npx hardhat run scripts/deploy.ts

# Type check only
npx tsc --noEmit</code></pre>
<hr />
<h2 id="conclusion"><a href="#conclusion" class="header-anchor">Conclusion</a></h2>
<p>TypeScript isn&#39;t mandatory for smart contracts, but it <strong>pays for itself</strong> by:</p>
<ol>
<li><p>Catching deployment bugs early &#40;before they cost money&#41;</p>
</li>
<li><p>Making code self-documenting &#40;types explain what variables are&#41;</p>
</li>
<li><p>Enabling IDE autocomplete &#40;less context-switching&#41;</p>
</li>
<li><p>Making refactoring safe &#40;type checker ensures consistency&#41;</p>
</li>
</ol>
<p>For a CS PhD, the learning curve is minimal—you already understand type systems. Spend a few hours learning syntax, then let TypeScript save you from silent failures on mainnet.</p>
<p>Start with the Hardhat template, gradually add type annotations, and you&#39;ll have a bulletproof smart contract development workflow.</p>
<div class="page-foot">
    Contact me by <a href="mailto:skchu@wustl.edu">E-mail</a> | <a href="https://github.com/kchu25">Github</a> | <a href="https://www.linkedin.com/in/kchu1/">Linkedin</a>
    <br>
    This work is licensed under <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a>.  Last modified: March 01, 2026.
    <br>
    Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia language</a>.
</div>
</div><!-- CONTENT ENDS HERE -->
    
    
        <script src="/libs/highlight/highlight.min.js"></script>
<script>
// Register Solidity language for highlight.js
hljs.registerLanguage('solidity', function(hljs) {
  return {
    keywords: {
      keyword: 'contract interface library pragma import using struct enum event modifier function returns return require revert assert emit new delete if else for while do break continue try catch throw this super constructor fallback receive ' +
                'public private internal external pure view payable virtual override constant immutable anonymous indexed storage memory calldata',
      literal: 'true false wei gwei ether seconds minutes hours days weeks years',
      built_in: 'msg block tx abi now sender value gas data origin gasprice blockhash gasleft address uint int bytes string bool mapping'
    },
    contains: [
      hljs.C_LINE_COMMENT_MODE,
      hljs.C_BLOCK_COMMENT_MODE,
      hljs.QUOTE_STRING_MODE,
      hljs.APOS_STRING_MODE,
      {
        className: 'number',
        begin: '\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)',
        relevance: 0
      },
      {
        className: 'type',
        begin: '\\b(uint|int|bytes|byte|string|address|bool|ufixed|fixed)(\\d+x\\d+|\\d+)?\\b'
      },
      {
        className: 'function',
        beginKeywords: 'function modifier event constructor fallback receive',
        end: '[{;]',
        excludeEnd: true,
        contains: [
          {
            className: 'title',
            begin: '[A-Za-z$_][0-9A-Za-z$_]*',
            relevance: 0
          },
          {
            className: 'params',
            begin: '\\(', end: '\\)',
            contains: [hljs.C_LINE_COMMENT_MODE, hljs.C_BLOCK_COMMENT_MODE]
          }
        ]
      }
    ]
  };
});

hljs.highlightAll();
hljs.configure({tabReplace: '    '});
</script>


    
  </body>
</html>
